
--------------------------------------------------------------------------------

######### PROBLEM LOG #########

--------------------------------------------------------------------------------

DATE: 3/4/2024
Problem: still need to make ft_ra & ft_rra. Functions missing.
Solved: yes.

--------------------------------------------------------------------------------

DATE: 3/4/2024
Problem: unsure? too many pushes from a to b, not printing any operations in between.
Solved: not fully, but found out that ft_initialize_list had a mistake. still loop issue after pushing everything from a to b.
Changed: pass the size of temp_stack to ft_initialize_list and use a for loop to iterate over the array
while (temp_stack[i])
to:
while (i < size)

--------------------------------------------------------------------------------

DATE: 3/4/2024
Problem: with example array, array is rb when not supposed to.
Solved: yes
Changed: found error in rotate_to_last_first, swapped conditions.
NOTE: check ft_rrotate_to_first and last: are those conditions correct or also swapped?? <---------------!!!!!!!!!!!

--------------------------------------------------------------------------------

DATE: 3/4/2024
Problem: infinite loop after pushing everything from stack_a to stack_b
Solved: yes
Changed: -

--------------------------------------------------------------------------------

DATE: 4/4/2024
Problem: Suddenly another infinite loop in first part of the code.
Solved: yes
Changed:
function to track size of stacks was incorrect: was always one too big.
function to find closest numbers in top and bottom were incorrect: moved the part of moving to the next element to end of the loop (skipped first element before).
function ft_equal had error to calculate distance to bottom: we added + 1 to equal that distance to the top starts at 1.
again mistake in how often to rotate: updated (for good?), not sure this is the last time i have to change this.

--------------------------------------------------------------------------------

DATE: 4/4/2024
Problem: void ft_search_lowest(t_list **stack, t_track *track)
Solved: yes
Changed:
tried to access out of bound memory, change if condition from:
if (temp->next->value > temp->value)
to:
if (temp->value < track->lowest_value)

--------------------------------------------------------------------------------

DATE: 4/4/2024
Problem: it doesnt sort properly 
Solved:  yes
Changed:
- ft_check_3 wasnt sorting properly. changed it completely and also updated ft_search_lowest, because the index of the to be checked stack might not be up to date when it starts, now it is.
- index for closest found value was wrong
- rotation and reverse rotation always one too many.
fixed now.
--------------------------------------------------------------------------------

DATE: 10/4/2024
Problem: initial checks for errors are not working
Solved: yes
Changed:
Now also accepts negative numeric (forgot to add the '-')
Removed unnecessary and wrong function that checks INT_MIN and INT_MAX.
Correctly frees stack now if error is encountered.
Temporarily added extra info to the printf on what error, musnt forget to remove for final version (just "Error").

--------------------------------------------------------------------------------

DATE: 10/4/2024
Problem: Doesnt work when we send a 0 in the list?!
Solved: yes
Changed:
Many mistakes when using a while loop and argc. all up to date for now.
--------------------------------------------------------------------------------

DATE: 10/4/2024
Problem: Must accept input as ./push_swap "10 8 12" and ./push_swap 10 8 12.
Solved: yes
Changed:
Added str_join before split to mimic the behaviour of the first string in argv being the programs name, so i did not have to alter all the other functions. 

--------------------------------------------------------------------------------

DATE: 15/04/2024
Problem: when a stack of 3 is in descending, it unnecessarily rotates and reverse rotates once. 
Solved: yes
Changed:
made if condition for every option since 3! = 6, so not too much to check all separate.

--------------------------------------------------------------------------------

DATE: 15/04/2024
Problem: When array size is bigger than 200 random numbers, nr of operations is too big. change algorithm.
Solved: no
Changed: created a v2, working on finding the most cheap number to push before pushing something from a to b

--------------------------------------------------------------------------------

DATE: 16/04/2024
Problem: size of stack_b is not being updated correctly: check all functions that use track->size_b and a for security
Solved: yes
Changed:
if statement was incorrect. when rotating to the last position if statement was if index is < size, but it should be if index is < size - 1.
--------------------------------------------------------------------------------

DATE: 18/04/2024
Problem: code works but it never seems to favor any other element than [0] from stack_a to be pushed. least amount of operations needs to be updated somewhere, but not sure where. favours a higher number?? dont understand.
Solved: yes
Changed:
forgot to reset stack_b after inner while loop.

--------------------------------------------------------------------------------
 
DATE: 21/04/2024
Problem: Currently calculating for EVERY number in the list total operations and choosing that one, but that does not sort. need to find correct location in B and only for that location count operations. then compare those to all others.
Solved: yes
Changed:
moved counting operations to outside innerloop.
--------------------------------------------------------------------------------
 
DATE: 21/04/2024
Problem: if stack_b is descing and stack_a is lower it wil do unnecessary rotations/wrong order.
Solved: yes
Changed:
made extra function that checked if stack_b was descending and if last value of b is higher, then its okay to just push.

--------------------------------------------------------------------------------
 
DATE: 21/04/2024
Problem: example: if track size = 3, border is 2, problematic for splitting size inhalf.
also not taking into calculating if during find lowest if the index = same as border. need to add that to either < or > (need to make sure pick right one.)
Solved: unsure?
Changed:

--------------------------------------------------------------------------------
 
DATE: 
Problem: 
Solved: 
Changed:

--------------------------------------------------------------------------------
 